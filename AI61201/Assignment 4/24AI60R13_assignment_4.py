# -*- coding: utf-8 -*-
"""24AI60R13_assignment_4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Dm-tMmMcl_Mq8-1GJcJl5LOy-UC8at03

<h4> NAME: VINAYAK MALI</h4>
<h4> ROLL: 24AI60R13</h4>

---

## Global Functions
"""

import numpy as np
print("Function to load image and convert to array")
def get_image_from_path(path):
    image = Image.open(path)
    image_array = np.array(image)
    return image, image_array

import requests
from io import BytesIO
from PIL import Image

print("Function which can fetch image from my github acc")
def fetch_image(url,display=False):
    response = requests.get(url)
    response.raise_for_status()
    image = Image.open(BytesIO(response.content)).convert("RGB")
    if display:
        display_image(image)
    return image

import numpy as np

print("Function to convert image to array")
def image_to_array(image):
    return np.array(image)

import matplotlib.pyplot as plt

print("Function to display image")
def display_image(image):
    plt.figure(figsize=(image.width / 100, image.height / 100), dpi=100)
    plt.imshow(image, cmap='gray')
    plt.axis('off')
    plt.show()

import numpy as np

print("DFT Function from scratch using numpy only")
def DFT(f):
    M , N = np.shape(f)                 # getting image shape
    F = np.zeros((M,N),dtype=complex)   # generating DFT with zeros
    exp_rows = np.zeros((M,M),dtype=complex)  # generating exponential matrix for rows
    exp_clumns = np.zeros((M,N),dtype=complex)  # generating exponential matrix for columns
    # Exp matrix for rows
    for u in range(M):
        for v in range(M):
            exp_rows[u,v] = np.exp(-2j * np.pi * u * v / M)
    # Exp matrix for columns
    for u in range(N):
        for v in range(N):
            exp_clumns[u,v] = np.exp(-2j * np.pi * u * v / N)
    # Applying matrix formula on all above matrices
    # Formula is exp*image*exp^H so I am making 2 dot products
    F = np.dot(exp_rows,f)
    F = np.dot(F,exp_clumns.conj().T)
    return F

"""Using above same logic I am creating IDFT"""

import numpy as np

print("IDFT Function from scratch using numpy only")
def IDFT(F):
    M, N = np.shape(F)
    f = np.zeros((M, N), dtype=complex)     # image is small f as per class notes/ppts
    exp_rows = np.zeros((M, M), dtype=complex)
    exp_columns = np.zeros((N, N), dtype=complex)
    # Exp matrix for rows
    for u in range(M):
        for v in range(M):
            exp_rows[u, v] = np.exp(2j * np.pi * u * v / M)
    # Exp matrix for columns
    for u in range(N):
        for v in range(N):
            exp_columns[u, v] = np.exp(2j * np.pi * u * v / N)

    # Formula is exp * F * exp^H, and I normalize by 1/(M*N)
    f = np.dot(exp_rows, F)  # First multiplication
    f = np.dot(f, exp_columns.conj().T)  # Second multiplication
    f /= (M * N)  # Normalize the result by the size of the input
    return f

import numpy as np
print("Library DFT function")
def library_DFT(f):
    F = np.fft.fft2(f)
    return F

import numpy as np
print("Library IDFT function")
def library_IDFT(F):
    f = np.fft.ifft2(F)
    return f

import numpy as np
print("Function to convert complex to int")
def complex_to_int(number):
    number = np.round(number.real).astype(int)
    return number

print("Function to get magnitude and phase part of complex number")
def get_magnitude_and_phase(complex_number):
    magnitude = np.sqrt(complex_number.real**2 + complex_number.imag**2)
    phase = np.arctan2(complex_number.imag, complex_number.real)
    return magnitude, phase

print("Maginitude and phase of IDFT matrix")
def get_magnitude_and_phase_of_matrix(matrix):
    magnitude = np.sqrt(matrix.real**2 + matrix.imag**2)
    phase = np.arctan2(matrix.imag, matrix.real)
    return magnitude, phase

"""Both functions are same but still keeping"""

print("Function to get complex number from magnitude and phase")
def get_complex_from_magnitude_and_phase(magnitude, phase):
    real_part = magnitude * np.cos(phase)
    imag_part = magnitude * np.sin(phase)
    complex_number = real_part + 1j * imag_part
    return complex_number

"""---

#### Example to check above with simple matrix
"""

image = np.array([[0, 1], [2, 3]])  # Example 2D array
my_DFT_result = DFT(image)
library_DFT_result = library_DFT(image)
print("Image:\n"+str(image))
print("DFT from scratch:\n"+str(my_DFT_result))
print("Library DFT:\n"+str(library_DFT_result))

# Validating
are_equal = np.allclose(my_DFT_result, library_DFT_result, atol=1e-10)
print("\nAre the DFT results equal?", are_equal)

print("Lets verify the above results in IDFT")
my_IDFT_result = IDFT(my_DFT_result)
library_IDFT_result = library_IDFT(my_DFT_result)
print("My IDFT:\n"+str(my_IDFT_result))
print("Library IDFT:\n"+str(library_IDFT_result))

"""IDFT is same

Lets check wther it retrive original matrix
"""

my_idft_int = np.round(my_IDFT_result.real).astype(int)
library_idft_int = np.round(library_IDFT_result.real).astype(int)

print("My IDFT as integers:\n", my_idft_int)
print("Library IDFT as integers:\n", library_idft_int)

"""Lets extract maginitude and phase"""

get_magnitude_and_phase_of_matrix(my_IDFT_result)

"""Results are matching as well as converting matrix back to normal properly

## Task 1
"""

print("Loading image a_3_task_1_input.png")
im_path = "/content/a_3_task_1_input.png"
im_t1, im_t1_array = get_image_from_path(im_path)
display_image(im_t1)

"""To calculate deviation I am using standard formula i.e. `my own appraoch`

$$
\sigma = \frac{\text{cutoff}}{division factor * \sqrt{2 \cdot \ln(2)}}
$$

Here i have take division factor so that i can reduce the sigma value and run a for loop to get multiple results
"""

print("Gussian bandpass filter")
def bandpass_filter(im, high_cutoff, low_cutoff, division_factor = 1, is_print = True):
    def calculate_sigma_from_cutoff(cut_off_value):
        sigma = cut_off_value / np.sqrt(2 * np.log(2))
        return sigma

    def gaussian_low_pass_filter(no_rows, no_cols, sigma):
        if is_print:
            print("Gussian low pass functions")
        x = np.linspace(-no_cols // 2, no_cols // 2, no_cols)
        y = np.linspace(-no_rows // 2, no_rows // 2, no_rows)
        X, Y = np.meshgrid(x, y)
        d = np.sqrt(X**2 + Y**2)
        low_pass_filter = np.exp(-(d**2) / (2 * (sigma**2)))
        return low_pass_filter

    def gaussian_high_pass_filter(no_rows, no_cols, sigma):
        if is_print:
            print("Gussian High Pass functions")
        low_pass = gaussian_low_pass_filter(no_rows, no_cols, sigma)
        high_pass_filter = 1 - low_pass
        return high_pass_filter

    rows, cols = im.shape
    F = DFT(im)

    low_sigma = calculate_sigma_from_cutoff(low_cutoff) / division_factor
    if is_print:
        print(f"Deviation (sigma) value from cutoff {low_cutoff} is {low_sigma}")
    low_pass = gaussian_low_pass_filter(rows, cols, low_sigma)

    high_sigma = calculate_sigma_from_cutoff(high_cutoff) / division_factor
    if is_print:
        print(f"Deviation (sigma) value from cutoff {high_cutoff} is {high_sigma}")
    high_pass = gaussian_high_pass_filter(rows, cols, high_sigma)

    band_pass = low_pass * high_pass
    filtered_result = F * band_pass

    f_complex = IDFT(filtered_result)
    # As we know it will return complex number matrix so I am converting it into int
    f_int = complex_to_int(f_complex)
    if is_print:
        print(f_int)
    # Checking minimum and maximum value of f_int
        print(f'\nMin value of f_int: {f_int.min()}')
        print(f'Max value of f_int: {f_int.max()}')
    # after running this code minimum value we get is -2 so I am cliping the values in range 0 to 255
    f = np.clip(f_int, 0, 255).astype(np.uint8)
    if is_print:
        print(f'\nMin value of f: {f.min()}')
        print(f'Max value of f: {f.max()}')
    return f

Gussian_filtered_image_array_scratch = bandpass_filter(im_t1_array, high_cutoff=100, low_cutoff=120, division_factor = 1)
Gussian_filtered_image_scratch = Image.fromarray(Gussian_filtered_image_array_scratch)
display_image(Gussian_filtered_image_scratch)

import cv2
import numpy as np
import matplotlib.pyplot as plt

def opencv_implementaion(img, high_cutoff = 100.0, low_cutoff = 120.0, division_factor = 1):
    def calculate_sigma_from_cutoff(cut_off_value):
        sigma = cut_off_value / np.sqrt(2 * np.log(2))
        return sigma

    # Perform DFT using OpenCV
    dft_opencv = cv2.dft(np.float32(img), flags=cv2.DFT_COMPLEX_OUTPUT)

    high_sigma = calculate_sigma_from_cutoff(high_cutoff) / division_factor
    low_sigma = calculate_sigma_from_cutoff(low_cutoff) / division_factor

    def create_gaussian_filter_opencv(shape, cutoff, sigma, filter_type='low'):
        rows, cols = shape
        x = np.linspace(-cols // 2, cols // 2 - 1, cols)
        y = np.linspace(-rows // 2, rows // 2 - 1, rows)
        X, Y = np.meshgrid(x, y)

        d = np.sqrt(X**2 + Y**2)

        if filter_type == 'low':
            gaussian_filter = np.exp(-(d**2) / (2 * (sigma ** 2)))
        elif filter_type == 'high':
            gaussian_filter = 1 - np.exp(-(d**2) / (2 * (sigma ** 2)))

        return gaussian_filter

    # Create OpenCV filters
    rows, cols = img.shape
    crow, ccol = rows // 2, cols // 2

    # Low-pass filter
    low_pass_mask = create_gaussian_filter_opencv(img.shape, low_cutoff, low_sigma, filter_type='low')
    low_pass_mask = np.stack((low_pass_mask, low_pass_mask), axis=-1)

    # High-pass filter
    high_pass_mask = create_gaussian_filter_opencv(img.shape, high_cutoff, high_sigma, filter_type='high')
    high_pass_mask = np.stack((high_pass_mask, high_pass_mask), axis=-1)

    # Apply filters
    filtered_opencv = dft_opencv * low_pass_mask * high_pass_mask
    idft_opencv = cv2.idft(filtered_opencv)
    result_opencv = cv2.magnitude(idft_opencv[:, :, 0], idft_opencv[:, :, 1])
    result_opencv = cv2.normalize(result_opencv, None, 0, 255, cv2.NORM_MINMAX).astype(np.uint8)

    return result_opencv, high_sigma, low_sigma

result_opencv, high_sigma, low_sigma = opencv_implementaion(im_t1_array, high_cutoff = 100.0, low_cutoff = 120.0, division_factor = 1)
print(f"High sigma: {high_sigma}")
print(f"Low sigma: {low_sigma}")

# Display results
plt.figure(figsize=(12, 6))
plt.subplot(1, 3, 1)
plt.title('Original Image')
plt.imshow(im_t1, cmap='gray')
plt.axis('off')

plt.subplot(1, 3, 2)
plt.title('Filtered Image (Scratch DFT)')
plt.imshow(Gussian_filtered_image_scratch, cmap='gray')
plt.axis('off')

plt.subplot(1, 3, 3)
plt.title("Filtered Image (OpenCV's DFT)")
plt.imshow(result_opencv, cmap='gray')
plt.axis('off')

plt.show()

"""Now lets check how smaller sigma values update the results"""

for division_factor in range(1,4):
    result_scratch = Image.fromarray(bandpass_filter(im_t1_array, high_cutoff=100, low_cutoff=120, division_factor = division_factor, is_print = False))
    result_opencv, high_sigma, low_sigma = opencv_implementaion(im_t1_array, high_cutoff = 100.0, low_cutoff = 120.0, division_factor = division_factor)
    plt.figure(figsize=(14, 5))
    plt.subplot(1, 3, 1)
    plt.text(0.5, 0.5, f'Gaussian band pass filter :\nSigma Values are as follows\n high_sigma:{round(high_sigma, 3)}\n low_sigma:{round(low_sigma, 3)}', fontsize=12, ha='right', va='center')
    plt.axis('off')

    plt.subplot(1, 3, 2)
    plt.title('Filtered Image (Custom DFT)')
    plt.imshow(result_scratch, cmap='gray')
    plt.axis('off')

    plt.subplot(1, 3, 3)
    plt.title("Filtered Image (OpenCV's DFT)")
    plt.imshow(result_opencv, cmap='gray')
    plt.axis('off')

    plt.show()

"""When the sigma value of a Gaussian filter decreases, the filter becomes narrower and less smoothing, preserving more detail and enhancing edges. However, it also increases sensitivity to noise and may introduce artifacts if too low.

As we can see after reducing sigma value to much image is getting completely distored in both custom and opencv appraoch

## Task 2

### Loading Images
"""

print("Image 1 for task 3")
im1_path = "/content/a_3_task_2_im1.png"
im1, im1_array = get_image_from_path(im1_path)
im1_array

print("Image 2 for task 3")
im2_path = "/content/a_3_task_2_im2.png"
im2, im2_array = get_image_from_path(im2_path)
im2_array

"""### Converting to DFT"""

print("DFT of image 1")
im1_dft = DFT(im1_array)
print(im1_dft)

print("DFT of image 2")
im2_dft = DFT(im2_array)
print(im2_dft)

"""### Magnitude and Phase"""

print("Magnitude and phase of image 1")
im1_magnitude, im1_phase = get_magnitude_and_phase_of_matrix(im1_dft)
print("Magnitude:\n"+str(im1_magnitude))
print("Phase:\n"+str(im1_phase))

print("Magnitude and phase of image 2")
im2_magnitude, im2_phase = get_magnitude_and_phase_of_matrix(im2_dft)
print("Magnitude:\n"+str(im2_magnitude))
print("Phase:\n"+str(im2_phase))

"""### Reconstruction

#### Im1_ver1

Im2 magnitude + Im1 phase

Generating complex number matrix i.e. `F` to pass to IDFT function
"""

print("Madified DFT Matrix")
F = get_complex_from_magnitude_and_phase(im2_magnitude, im1_phase)
print(F)

print("Creating modified image 1 Matrix")
im1_ver1_IDFT = IDFT(F)
print(im1_ver1_IDFT)

print("Converting Complex matrix to int matrix so that we can generate image")
im1_ver1_IDFT_int = complex_to_int(im1_ver1_IDFT)
print(f'Shape of im1_ver1_int: {im1_ver1_IDFT_int.shape}')
print(f'Dtype of im1_ver1_int: {im1_ver1_IDFT_int.dtype}')
print(f'Min value of im1_ver1_int: {im1_ver1_IDFT_int.min()}')
print(f'Max value of im1_ver1_int: {im1_ver1_IDFT_int.max()}')
print(im1_ver1_IDFT_int)

"""As we can see minimum value is -118 so we to get the pixcel value in range 0 to 255

"""

print("TRansforming pixcel values in ranage 0-255")
im1_ver1_IDFT_int_in_range = (im1_ver1_IDFT_int - im1_ver1_IDFT_int.min()) / (im1_ver1_IDFT_int.max() - im1_ver1_IDFT_int.min()) * 255
print(im1_ver1_IDFT_int_in_range)

print("Converting numpy array into image")
im1_ver1 = Image.fromarray(im1_ver1_IDFT_int_in_range.astype('uint8'))
print("Image created succesfully. Saving the image")
im1_ver1.save("im1_ver1.png")

print("IM1_VER1 Result:\n")
im1_ver1, im1_ver1_array = get_image_from_path("im1_ver1.png")
im1_ver1

"""Lets Visualize all 3 images"""

import matplotlib.pyplot as plt

fig, axs = plt.subplots(1, 3, figsize=(15, 5))

axs[0].title.set_text("Image 1")
axs[0].imshow(im1, cmap='gray')
axs[0].axis('off')

axs[1].title.set_text("Image 2")
axs[1].imshow(im2, cmap='gray')
axs[1].axis('off')

axs[2].title.set_text("Image 1 Version 1")
axs[2].imshow(im1_ver1, cmap='gray')
axs[2].axis('off')

plt.show()





"""#### Im1_ver2
Im1 magnitude + Im2 phase

Generating complex number matrix i.e. `F` to pass to IDFT function
"""

print("Madified DFT Matrix")
F = get_complex_from_magnitude_and_phase(im1_magnitude, im2_phase)
print(F)

print("Creating modified image 2 Matrix")
im1_ver2_IDFT = IDFT(F)
print(im1_ver2_IDFT)

print("Converting Complex matrix to int matrix so that we can generate image")
im1_ver2_IDFT_int = complex_to_int(im1_ver2_IDFT)
print(f'Shape of im1_ver1_int: {im1_ver2_IDFT_int.shape}')
print(f'Dtype of im1_ver1_int: {im1_ver2_IDFT_int.dtype}')
print(f'Min value of im1_ver1_int: {im1_ver2_IDFT_int.min()}')
print(f'Max value of im1_ver1_int: {im1_ver2_IDFT_int.max()}')
print(im1_ver2_IDFT_int)

"""As we can see minimum value is -50 and maximum value is 321 i.e. both are out off rnage so we to get the pixcel value in range 0 to 255

"""

print("TRansforming pixcel values in ranage 0-255")
im1_ver2_IDFT_int_in_range = (im1_ver2_IDFT_int - im1_ver2_IDFT_int.min()) / (im1_ver2_IDFT_int.max() - im1_ver2_IDFT_int.min()) * 255
print(im1_ver2_IDFT_int_in_range)

print(f'Min value of im1_ver1_int: {im1_ver2_IDFT_int_in_range.min()}')
print(f'Max value of im1_ver1_int: {im1_ver2_IDFT_int_in_range.max()}')

print("Converting numpy array into image")
im1_ver2 = Image.fromarray(im1_ver2_IDFT_int_in_range.astype('uint8'))
print("Image created succesfully. Saving the image")
im1_ver2.save("im1_ver2.png")

print("IM1_VER2 Result:\n")
im1_ver2, im1_ver2_array = get_image_from_path("im1_ver2.png")
im1_ver2

"""Lets Visualize all 3 images"""

import matplotlib.pyplot as plt

fig, axs = plt.subplots(1, 3, figsize=(15, 5))

axs[0].title.set_text("Image 1")
axs[0].imshow(im1, cmap='gray')
axs[0].axis('off')

axs[1].title.set_text("Image 2")
axs[1].imshow(im2, cmap='gray')
axs[1].axis('off')

axs[2].title.set_text("Image 1 Version 2")
axs[2].imshow(im1_ver2, cmap='gray')
axs[2].axis('off')

plt.show()

"""#### Result of Task 2"""

import matplotlib.pyplot as plt

fig, axs = plt.subplots(1, 3, figsize=(15, 5))

axs[0].title.set_text("Image 1")
axs[0].imshow(im1, cmap='gray')
axs[0].axis('off')

axs[1].title.set_text("Image 1 Version 1 (Magnitude Replaed)")
axs[1].imshow(im1_ver1, cmap='gray')
axs[1].axis('off')

axs[2].title.set_text("Image 1 Version 2 (Phase Replaed)")
axs[2].imshow(im1_ver2, cmap='gray')
axs[2].axis('off')

plt.show()

"""<h3> Conclusion </h3>

As we know after performing DFT we get complex numbers and we calculate magnitude and phase from it.

Magnitude represents the amplitude of the diffrent frequencies.

Phase stores the position the different frquency.

for an image most important part is structure that is nothing but the position of an frquency of an image which leads us to conclude that phase is the most important part of an image. Magnitude also play important role as it store frquecy value but without structure it is worthless. But in opposite case even though we don't have amplitude we can still generate image just based structure.

The above theory is proved by im1_ver1 and im1_ver2
we can see that `im1_ver1` is more `closer` to `original` image.

Because in ver 1 we have changed the magnitude so with the help of phase that is image structure we get the closest image to original image.

On the other hand in version to we lost the structure. ver 2 is showing some other image structure / outline

## Task 3

### Aliasing in the frequency domain
"""

print("Loading Image a_3_task_3_input_a.png")
im_a_path = "/content/a_3_task_3_input_a.png"
im_a, im_a_array = get_image_from_path(im_a_path)
im_a

print("DFT and Magnitude")
dft_im_a = cv2.dft(np.float32(im_a_array), flags=cv2.DFT_COMPLEX_OUTPUT)
dft_shifted_a = np.fft.fftshift(dft_im_a)
magnitude_spectrum_a = cv2.magnitude(dft_shifted_a[:, :, 0], dft_shifted_a[:, :, 1])
original_log_img = np.log(magnitude_spectrum_a + 1)

print("Subsampled Image as per instructions: DFT and Magnitude")
subsampled_im_a_array = im_a_array.copy()
subsampled_im_a_array[::2, ::2] = 0
dft_subsampled_a = cv2.dft(np.float32(subsampled_im_a_array), flags=cv2.DFT_COMPLEX_OUTPUT)
dft_shifted_subsampled_a = np.fft.fftshift(dft_subsampled_a)
magnitude_spectrum_subsampled_a = cv2.magnitude(dft_shifted_subsampled_a[:, :, 0], dft_shifted_subsampled_a[:, :, 1])
subsampled_log_img2 = np.log(magnitude_spectrum_subsampled_a + 1)

print("Plotting the magnitude of both")
plt.figure(figsize=(12, 6))
plt.subplot(1, 2, 1)
plt.title('Magnitude Spectrum of Original Image')
plt.imshow(original_log_img, cmap='gray')
plt.axis('off')

plt.subplot(1, 2, 2)
plt.title('Magnitude Spectrum of Subsampled Image')
plt.imshow(subsampled_log_img2, cmap='gray')
plt.axis('off')

plt.show()

plt.figure(figsize=(12, 6))
plt.subplot(1, 2, 1)
plt.title('Original Image')
plt.imshow(im_a, cmap='gray')
plt.axis('off')

plt.subplot(1, 2, 2)
plt.title('Subsampled Image')
plt.imshow(subsampled_im_a_array, cmap='gray')
plt.axis('off')

plt.show()

"""EXPLANATION !!!

**Original Image (Left):** The magnitude spectrum shows a clear central area for low frequencies and a structured pattern for high frequencies around it. The bright center represents lower frequency components, which help define the overall structure of the image.

**Subsampled Image (Right):** The magnitude spectrum of the subsampled image looks blurred and distorted. This happens because of aliasing, which occurs when we skip every other pixel. High-frequency details mix into lower frequencies, making the spectrum less clear. Patterns from the original image are not as sharp or distinct, especially around the edges.

The main difference is aliasing. It becomes more noticeable when we lose information by skipping pixels. This causes the frequency distribution to become less organized.

### Aliasing in the Spatial domain
"""

import cv2
import numpy as np
import matplotlib.pyplot as plt

dft = cv2.dft(np.float32(cv2.imread('a_3_task_3_input_b.png', cv2.IMREAD_GRAYSCALE)), flags=cv2.DFT_COMPLEX_OUTPUT)
dft_shifted = np.fft.fftshift(dft)
magnitude_spectrum_original = cv2.magnitude(dft_shifted[:, :, 0], dft_shifted[:, :, 1])
magnitude_spectrum_original = np.log1p(magnitude_spectrum_original)
dft_shifted[:, ::3, :] = 0
magnitude_spectrum_original_normalized = cv2.normalize(magnitude_spectrum_original, None, 0, 255, cv2.NORM_MINMAX)
magnitude_spectrum_original_normalized = np.uint8(magnitude_spectrum_original_normalized)

magnitude_spectrum_subsampled = cv2.magnitude(dft_shifted[:, :, 0], dft_shifted[:, :, 1])
magnitude_spectrum_subsampled = np.log1p(magnitude_spectrum_subsampled)
magnitude_spectrum_subsampled_normalized = cv2.normalize(magnitude_spectrum_subsampled, None, 0, 255, cv2.NORM_MINMAX)
magnitude_spectrum_subsampled_normalized = np.uint8(magnitude_spectrum_subsampled_normalized)

idft_shifted = cv2.idft(np.fft.ifftshift(dft_shifted))
reconstructed_image = cv2.magnitude(idft_shifted[:, :, 0], idft_shifted[:, :, 1])

reconstructed_image_normalized = cv2.normalize(reconstructed_image, None, 0, 255, cv2.NORM_MINMAX)
reconstructed_image_normalized = np.uint8(reconstructed_image_normalized)

plt.figure(figsize=(12, 10))

plt.subplot(2, 2, 1)
plt.title('Original Image')
plt.imshow(input_image, cmap='gray')
plt.axis('off')

plt.subplot(2, 2, 2)
plt.title('Reconstructed Image (IDFT after Subsampling)')
plt.imshow(reconstructed_image_normalized, cmap='gray')
plt.axis('off')

plt.subplot(2, 2, 3)
plt.title('Magnitude Spectrum of Original DFT')
plt.imshow(magnitude_spectrum_original_normalized, cmap='gray')
plt.axis('off')

plt.subplot(2, 2, 4)
plt.title('Magnitude Spectrum of Subsampled DFT')
plt.imshow(magnitude_spectrum_subsampled_normalized, cmap='gray')
plt.axis('off')

plt.tight_layout()
plt.show()

"""The "Reconstructed Image" shows some problems after subsampling and applying the inverse discrete Fourier transform (IDFT). Here are the main issues:

1. **Blurring or Ghosting**: The image looks like it has several faint copies of the original, especially on the right side. This happens because we skipped some data, causing these overlapping copies to appear.

2. **Distortion**: Some details, especially sharp areas, are lost, making the image look fuzzy. This loss is due to cutting out high-frequency details that give the image its clarity.

#### My VIew:

This problem is called **aliasing**. It happens when we don’t sample the image at a high enough rate to capture all its details. By removing every 3rd piece of data, we change the frequencies that describe the image, losing important information.

When we try to recreate the image, the missing parts cause those overlapping copies or "ghosts" to show up. How these ghosts look depends on how much data we skipped.

In short, subsampling leads to:

- **Loss of detail**: The image becomes blurry.
- **Aliased artifacts**: Faded copies of the image appear.

THANK YOU
"""